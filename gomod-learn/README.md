#go modules学习心得

go modules 可以说让go开发变得更加无脑轻松，其基本上淘汰了GOPATH，实现了类语言级的包管理工具。 有了go mod，我们不需要再在gopath下进行开发。
#总的来说，go modules的核心主要有三个部分：modules，packages和version，每一个核心部分内部以及底层都有着一定复杂的算法和实现方式。此文暂时不做底层的介绍，不过最近看了个帖子觉得受益非浅，链接：https://duyanghao.github.io/golang-module/

# go modules的主要命令
go mod init (初始化module，后面可以加module的name)
go mod tidy(增加所需要的包并移除无用的包)
go mod download(下载模块到本地缓存)
go mod graph(打印各模块的依赖图)

以上是常用的命令，但是这里要提一下的是在go.mod 文件中的几个命令
replace 替换引用制定的包，比如有的时候我们对依赖包的版本有一定的需求
require 所需要的依赖包，如果不是直接引用 用// indirect标注

# 稍后补写go mod 的semver规范（语义化版本规范）和mvs最小版本选择算法的内容：
-----semver：定义了版本的格式：主版本号，次版本号以及修订号。递增规则如下：
主版本号：当做了不兼容的api修改
次版本号：当做了向下兼容的功能新增（之前的api正常使用）
修订号：当做了向下兼容的问题修正

比如当前版本号为v3.3.9，如果：
修改后的项目导致依赖这个代码的项目需要修改代码，则版本号升为v4.0.0；
修改后的项目不影响原依赖项目的接口，则版本号升为v3.4.0；
修改了bug，不影响原有项目也没有增加功能，版本号升为v3.3.10；

以上的改动需要修改对应包的路径如{path}/version

-----mvs: 最小版本选择算法，举个栗子：如果我们的包1依赖包3的v1.1.1，包2依赖包3的v1.2.1，则当我们实现一个功能且需要同时使用包1和包2，那我们在编译自己的module时，应该选择包3的版本为v1.2.1； 假若包1情况不变，但包2依赖包3的v2.0.1，那么情况就不一样了，在编译自己的module的时候，我们既要引用v1.1.1，也要引用包v2.0.1

#还在继续研究～～～～

