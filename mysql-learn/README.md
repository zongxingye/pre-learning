#mysql-的学习
#1.索引：
·索引的目的，索引的底层实现结构以及为什么要选择b+树。了解不同引擎的不同索引的底层结构

·主键索引，二级索引的使用以及底层存储区别。

·自增主键的使用场景（尽量使用自增主键作为查询条件以此避免不必要的回表，减少因为插入或者删除数据的时候可能造成的页分裂或页合并）

·若必需使用业务字段作为主键，尽量选择字段较短的作为索引，这样主键长度越小，普通索引的叶子结点越小，普通索引底层的存储所消耗空间就越小

·覆盖索引（某个查询语句命中了索引覆盖了查询需求而无需回表，从而加速了查询的效率）

·联合索引：根据具体所需查询的数据，建立多个字段一起的索引。

·最左匹配：针对联合索引，根据其定义时候的字段顺序，由左开始饿的顺序来排序。

·索引下堆：mysql5.6前，若联合索引中的查询一组符合条件的数据时，需要先命中索引然后逐个回表查询，造成回表次数过多而引发的效率低下；
而在5.6之后，在对索引遍历过程中，直接抛弃不满足条件的数据组，减少了回表次数。

#2.锁
mysql中主要有三类锁：全局锁，表级锁和行级锁。主要谈innoDB引擎的
·全局锁：使用较少，典型场景是需要备份全数据库的时候，通过flush tables with Read Lock，即把整个表select出来存成文本。
还有是set global readonly=true的方式，但是这种方法不推荐的原因如下：一是readonly的值会被用来区分是主还是从库；二是在异常处理机制方面有些差异
前者在客户端断开链接时候，会自动释放这个全局锁，而后者会一直keep这个状态，风险很高。

·表级锁：也分为两种，一种是所谓的表锁（lock tables ... read/write），另一种是MDL（元数据锁）。
表锁顾名思义,分为读锁和写锁。lock tables语法会限制本线程以及其他线程。当然对于线程加读锁则会阻塞本线程以及其他线程的写语句；加了写锁的线程会阻塞本线程的写和其他线程的读写

·对于MDL来说，不需要显示调用，而是在访问一个表的时候自动加上（比如开启一个事务，对表内的数据进行读写）。mdl锁的特点是，加了读锁但是多个线程还是可以对同一张表进行增删改查。

·行锁：在引擎层实现的，是innodb特有。顾名思义是锁住某一行，也分读写锁